import os as os
import sys
import os.path
from csv import writer
import math
import numpy as np
from joblib import Parallel, delayed
import multiprocessing
import time
import shutil
from mpi4py import MPI

def sliding_window(data, block_size, step, counts, ent):
    entropy = 0.0
    for i in range(block_size):
        counts[data[i]] += 1
    for i in range(counts.shape[0]):
        if counts[i] > 0:
            entropy += - (counts[i] / block_size) * np.log2(counts[i] / block_size)
    ent[0] = entropy

    for i in range(1, data.shape[0] - block_size):
        dec = counts[data[i - 1]]
        inc = counts[data[i + block_size - 1]]
        counts[data[i - 1]] -= 1
        counts[data[i + block_size - 1]] += 1
        entropy -= -dec / block_size * np.log2(dec / block_size)
        if dec > 1:
            entropy += -(dec - 1) / block_size * np.log2((dec - 1) / block_size)
        if inc > 0:
            entropy -= -inc / block_size * np.log2(inc / block_size)
        entropy += - (inc + 1) / block_size * np.log2((inc + 1) / block_size)
        if i % step == 0:
            ent[i // step] = (entropy)

def getEntropySlidingWindowFeatures(file_name):
    extracted_feats = {}
    byte_data = open(file_name,'rb')    
    corr = {str(key): key for key in range(10)}
    corrl = {'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15, '?': 16}
    corr.update(corrl)
    block_size = 10000
    step = 100

    hex_data = [hex(byte)[2:] for byte in byte_data.read()]
    hex_data = ''.join(hex_data)
    chararray = np.array([corr[x] for x in hex_data])
    counts = np.zeros(17, dtype=np.float)    
    if(chararray.shape[0] > block_size):
        ent_size = (chararray.shape[0] - block_size) / step + 1
    else:
        ent_size = 1
        block_size = chararray.shape[0]        
    ent = np.zeros(int(ent_size))
    sliding_window(chararray, block_size, step, counts, ent)
    
    extracted_feats['ent_mean'] = np.mean(ent)
    extracted_feats['ent_var'] = np.var(ent)
    extracted_feats['ent_median'] = np.median(ent)
    extracted_feats['ent_max'] = np.max(ent)
    extracted_feats['ent_min'] = np.min(ent)
    extracted_feats['max-min'] = np.max(ent) - np.min(ent)
    
    byte_data.close()
    return extracted_feats

# Get whole file entropy (check obfuscation)
def getWholeFileEntropy(fileName):
    # read the whole file into a byte array
    with open(fileName, "rb") as f:
        # Read the whole file at once
        byteArr = f.read()
    f.close()
    fileSize = len(byteArr)
    if fileSize == 0 :
        print("The file: ", fileName, " is giving size 0")
        return [0]
    # calculate the frequency of each byte value in the file
    freqList = []
    for b in range(256):
        ctr = 0
        for byte in byteArr:
            if byte == b:
                ctr += 1
        freqList.append(float(ctr) / float(fileSize)) # Error in this line if the file is empty

    # Shannon entropy (the interesting one) (min bits per byte-character)
    ent = 0.0
    for freq in freqList:
        if freq > 0:
            ent = ent + freq * math.log(freq, 2)
    ent = -ent
    #print ('Shannon entropy: ', ent)
    return ent

def getFeatures(fname,hexFolder):
    feature_counts = []
    fasm = open(hexFolder + fname, 'r', errors='ignore')

    filesize = os.path.getsize(hexFolder + fname)
    entWholeFile = getWholeFileEntropy(hexFolder + fname)

    entropyExtracted = getEntropySlidingWindowFeatures(hexFolder + fname)
    entFeatures = list(entropyExtracted.values())
    entMean = entFeatures[0]
    entVar = entFeatures[1]
    entMedian = entFeatures[2]
    entMax = entFeatures[3]
    entMin = entFeatures[4]
    entMaxMin = entFeatures[5]
    print(fname," entWholeFile: ",str(entWholeFile)," entMean: ",str(entMean)," entVar: ",str(entVar)," entMedian: ",str(entMedian)," entMax: ",str(entMax)," entMin: ",str(entMin)," entMaxMin: ",str(entMaxMin)," fileSize: ", str(filesize))

    count_vals = [entWholeFile, entMean, entVar, entMedian, entMax, entMin, entMaxMin, filesize]
    feature_counts.append([fname[:fname.find('.byte')]] + count_vals)

    return feature_counts


def extractHexFeatures():

    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    nprocs = comm.Get_size()

    sumToRank = int(sys.argv[1])
    hexFolder = sys.argv[2]
    hexOutput = sys.argv[3]

    rank+=sumToRank
    print("Rank: ", rank)
    # Get .hex file
    listOfHexFiles = os.listdir(hexFolder)
    hexFile = str(listOfHexFiles[rank])
    print("HexFile: ", hexFile)
    # Extract features from .byte file
    feature_counts = getFeatures(hexFile,hexFolder)
    # Write features to .csv file
    individualOutputCsv = hexOutput+hexFile+".csv"
    with open(individualOutputCsv, 'w') as f:
        fw = writer(f)
        fw.writerows(feature_counts)
        f.close()

extractHexFeatures()



